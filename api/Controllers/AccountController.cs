using api.Data; // for DataContext class
using Microsoft.AspNetCore.Mvc; // for  [HttpPost("register")]
using System.Threading.Tasks; // for Task<ActionResult
using api.Entities; // for AppUser class reference
using System.Security.Cryptography; // for HMACSHA512
using System.Text; // for Encoding
using api.DTOs; // for RegisterDto class
using Microsoft.EntityFrameworkCore; // for AnyAsync()
using api.Interfaces;

namespace api.Controllers
{
    public class AccountController:BaseApiController
    {
/*This controller provides the end-point for the registration of user.
Such end point name is Register.
For registration, we need the new user's UserName and Password because ID could be generated by SQLite database itself.
In order to access the database, we need the object of DataContext hence we can define _context as private data member which gets initialized inside the constructor.

We need to use here POST method as we are going to accept the new user's UserName and Password in the BODY of request or Query Request.
so , we just need to add the attribute as [HttpPost(<name of end point>)]
*/
    private readonly DataContext _context;
    private readonly ITokenService _tokenService;

    public AccountController(DataContext context, ITokenService tokenService){
        _context = context;
        _tokenService = tokenService;
    }

     /* This End Point supports only Query request i.e. parameters are present inside query of Request.
        here, two actual parameters of this method Register because we are going to 
        receive these two parameters in the  query of Request.
        Actually, we can specify here by adding additional attribute in the signature like [FromBody],[FromForm],[FromQuery] etc 
        e.g public async Task<ActionResult<AppUser>>Register([FromQuery]string username, string password) -- getting the parameters from Query of request
        But we dont need to specify any attributes because we have used [ApiController] attribute over BaseApiController 
        class hence its properites are also inherited for AccountController also.
        Here, [ApiController] look after all internal mechanism.

        Note: Below end point is not going to work when parameters are inside BODY of request 
        because to handle that kind of request, we need the DTO object.
        */
    

   [HttpPost("registerq")]
   public async Task<ActionResult<AppUser>>Register(string username, string password)
    {
        if ( await IsUserExists(username))
            return BadRequest("User already existed");
       //HMACSHA512 built-in supports the cryptography operations hence use it.
       using var hmac = new HMACSHA512(); 
       //why using keyword is used? ans-> to invoke the disposal method after its execution.
       //Create the new user 
       var objUser = new AppUser{
           UserName = username,
           PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(password)),
           PasswordSalt = hmac.Key 
          };
           //ComputerHash taks an byte array but given username is just a string hence we need to convert it into byte array by using Encoding.UTF8 method which is part of System.Text namespace.
        _context.Users.Add(objUser); //User.Add() just adds the changes into EntityFramework
        //now we need to update the database asynchronously.
        await _context.SaveChangesAsync();
        return objUser;

    }

     /* below End Point supports only POST request i.e. parameters are present inside body of Request.
        here, DTO object is used to hold the parameters which are inside body of request
     
        Actually, we can specify here by adding additional attribute in the signature like [FromBody],[FromForm],[FromQuery] etc 
        e.g public async Task<ActionResult<AppUser>>Register([FromBody]string username, string password) -- getting the parameters from Body of request
        But we dont need to specify any attributes because we have used [ApiController] attribute over BaseApiController 
        class hence its properites are also inherited for AccountController also.
        Here, [ApiController] look after all internal mechanism.
       
        */
    
    [HttpPost("register")]
    //public async Task<ActionResult<AppUser>>Register(RegisterDto regDtoObj)
    // instead of returning AppUser object, now return the UserDto class object.
    public async Task<ActionResult<UserDto>>Register(RegisterDto regDtoObj)
    {
        if ( await IsUserExists(regDtoObj.Username))
            return BadRequest("User already existed");

        /* here, parameters of request are available inside regDtoObj object */
         //HMACSHA512 built-in supports the cryptography operations hence use it.
       using var hmac = new HMACSHA512(); 
       //why using keyword is used? ans-> to invoke the disposal method after its execution.
       //Create the new user 
        var objUser = new AppUser{
            UserName = regDtoObj.Username.ToLower(), /* store the username in small case inside db */
            PasswordHash = hmac.ComputeHash(Encoding.UTF8.GetBytes(regDtoObj.Password)),
            PasswordSalt = hmac.Key
        };
          //ComputerHash taks an byte array but given username is just a string hence we need to convert it into byte array by using Encoding.UTF8 method which is part of System.Text namespace.
        _context.Users.Add(objUser); //User.Add() just adds the changes into EntityFramework
        //now we need to update the database asynchronously.
        await _context.SaveChangesAsync();

       /*
        return objUser;
        After implementation of token, we need to return the UserDto instead of objUser */
        return new UserDto{
            Username = objUser.UserName,
            Token =  _tokenService.CreateToken(objUser)
        };
    }
    /* Internal function verifying the existence of user.
    Register() end point creates the new user hence before creation of new user, we could verify wheather given user is already existed.
    If existed then return Error message as an exception
     */
    private async Task<bool> IsUserExists(string username)
    {
        return await _context.Users.AnyAsync( x=> x.UserName == username.ToLower());
        /* Why AnyAsync() is used , its namespace is Microsoft.EntityFrameworkCore; */
    }

    /* This end point is used to autheticate the user for login hence called it as login */
    [HttpPost("login")]
    public async Task<ActionResult<UserDto>>Login(LoginDto loginDto)
    {
        var objUser = await _context.Users.SingleOrDefaultAsync( x=>x.UserName==loginDto.Username);
        /* why SingleOrDefaultAsync() is choosed here?
        Based on its description, it looks more suitable for this requirement than other methods like Find(), FirstOrDefaultAsync(), FindAsync(), SingleAsync() etc.
        As it is throwing exception in case of more than one sequence hence it choosed over SingleAsync()*/
        /*
        Note => In x.UserName==loginDto.Username statement, x.UserName belongs the Entity Model and loginDto.Username belongs to DTO model */
        
        /* in case, given user is not found in the database then objUser would be NULL */
        if( objUser==null)
            return Unauthorized("Invalid username"); // Unauthorized() is provided by ControllerBase
        using var hmac = new HMACSHA512(objUser.PasswordSalt);
        var computeHashValue = hmac.ComputeHash(Encoding.UTF8.GetBytes(loginDto.Password));
        for (int i=0; i<computeHashValue.Length;i++)
        {
            if ( computeHashValue[i] != objUser.PasswordHash[i])
                return Unauthorized("Invalid password!");
        }
         /*
        return objUser;
        After implementation of token, we need to return the UserDto instead of objUser */
        return new UserDto{
            Username = objUser.UserName,
            Token =  _tokenService.CreateToken(objUser)
        };
    }
    }
}